Часть 1.
1. Реализуйте алгоритм, определяющий, все ли символы в строке встречаются только один раз.
А если при этом запрещено использование дополнительных структур данных?

2. Для двух строк напишите метод, определяющий, является ли одна строка перестановкой другой.

3. Напишите метод, заменяющий все пробелы в строке символами '%20'. Можете считать, что длина строки позволяет
сохранить дополнительные символы, а фактическая длина строки известна заранее.
(Примечание: при реализации метода на Java для выполнения операции «на месте» используйте символьный массив.)
Пример:
Ввод: "Mr John Smith "
Вывод: "Mr%20John%20Smith"

4. Напишите функцию, которая проверяет, является ли заданная строка перестановкой палиндрома. (Палиндром – слово
или фраза, одинаково читающиеся в прямом и обратном направлении; перестановка – строка, содержащая те же символы
в другом порядке.) Палиндром не ограничивается словами из словаря.
Пример:
Ввод: tact cоа
Вывод: True (перестановки: "taco cat", "atco cta", и т.д.)

5. Существуют три вида модифицирующих операций со строками: вставка символа, удаление символа и замена символа.
Напишите функцию, которая проверяет, находятся ли две строки на расстоянии одной модификации (или нуля модификаций).
Пример:
pale, ple -> true
pales, pale -> true
pale, bale -> true
pale, bake -> false

6. Реализуйте метод для выполнения простейшего сжатия строк с использованием счетчика повторяющихся символов.
Например, строка ааЬсссссааа превращается в а2bс5а3. Если «сжатая» строка не становится короче исходной, то метод
возвращает исходную строку. Предполагается, что строка состоит только из букв верхнего и нижнего регистра (a-z).

7. Имеется изображение, представленное матрицей NxN; каждый пиксел представлен 4 байтами. Напишите метод для поворота
изображения на 90 градусов. Удастся ли вам выполнить эту операцию «на месте»?

8. Напишите алгоритм, реализующий следующее условие: если элемент матрицы MxN равен 0, то весь столбец и вся строка
обнуляются.

9. Реализуйте метод isSubstring, проверяющий, является ли одно слово подстрокой другого. Для двух строк s1 и s2
напишите код, который проверяет, получена ли строка s2 циклическим сдвигом s1, используя только один вызов метода
isSubstring (пример: слово waterbottle получено циклическим сдвигом erbottlewat).


Часть 2.
1. Напишите код для удаления дубликатов из несортированного связного списка. Как вы будете решать задачу, если
использовать временный буфер запрещено?

2. Реализуйте алгоритм для нахождения в односвязном списке k-го элемента с конца.

3. Реализуйте алгоритм, удаляющий узел из середины односвязного списка (то есть узла, не являющегося ни начальным,
ни конечным – не обязательно находящегося точно в середине). Доступ предоставляется только к этому узлу.
Пример:
Ввод: узел с из списка a->b->c->d->e->f
Вывод: ничего не возвращается, но новый список имеет вид: a->b->d->e->f

4. Напишите код для разбиения связного списка вокруг значения х так, чтобы все узлы, меньшие х, предшествовали узлам,
большим или равным х. Если х содержится в списке, то значения х должны следовать строго после элементов, меньших х
(см. далее). Элемент разбивки х может находиться где угодно в «правой части»; он не обязан располагаться между левой
и правой частью.
Пример:
Ввод: 3->5->8->5->10->2->1 [значение разбивки = 5]
Вывод: 3->1->2->10->5->5->8

5. Два числа хранятся в виде связных списков, в которых каждый узел представляет один разряд. Все цифры хранятся в
обратном порядке, при этом младший разряд (единицы) хранится в начале списка. Напишите функцию, которая суммирует два
числа и возвращает результат в виде связного списка.
Пример:
Ввод: (7->1->6) + (5->9->2), то есть 617 + 295.
Вывод: 2->1->9, то есть 912.
Решите задачу, предполагая, что цифры записаны в прямом порядке.
Пример:
Ввод: (6->1 ->7) + (2->9->5), то есть 617 + 295.
Вывод: 9->1->2, то есть 912.

6. Реализуйте функцию, проверяющую, является ли связный список палиндромом.

7.Проверьте, пересекаются ли два заданных (одно-)связных списка. Верните узел пересечения. Учтите, что пересечение
определяется ссылкой, а не значением. Иначе говоря, если k-й узел первого связного списка точно совпадает (по ссылке)
с j-м узлом второго связного списка, то списки считаются пересекающимися.

8. Для кольцевого связного списка реализуйте алгоритм, возвращающий начальный узел петли. Кольцевой связный список –
это связный список, в котором указатель следующего узла ссылается на более ранний узел, образуя петлю.
Пример:
Ввод: A->B->C- >D->E->C (предыдущий узел C)
Вывод: C


Часть 3.
1. Опишите, как бы вы использовали один одномерный массив для реализации трех стеков.

2. Как реализовать стек, в котором кроме стандартных функций push и рор будет поддерживаться функция min,
возвращающая минимальный элемент? Все операции - push, рор и min - должны выполняться за время О(1).

3. Как известно, слишком высокая стопка тарелок может развалиться. Следовательно, в реальной жизни, когда высота
стопки превысила бы некоторое пороговое значение, мы начали бы складывать тарелки в новую стопку. Реализуйте структуру
данных SetOfStacks, имитирующую реальную ситуацию. Структура SetOfStack должна состоять из нескольких стеков,
новый стек создается, как только предыдущий достигнет порогового значения. Методы SetOfStacks.push() и SetOfStacks.рор()
должны вести себя так же, как при работе с одним стеком (то есть метод рор() должен возвращать те же значения, которые
бы он возвращал при использовании одного большого стека). Реализуйте функцию popAt(int index), которая осуществляет
операцию рор с заданным внутренним стеком.

4. Напишите класс MyQueue, который реализует очередь с использованием двух стеков.

5. Напишите программу сортировки стека, в результате которой наименьший элемент оказывается на вершине стека. Вы можете
использовать дополнительный временный стек, но элементы не должны копироваться в другие структуры данных
(например, в массив). Стек должен поддерживать следующие операции: push, рор, peek, isEmpty.

6. В приюте для животных есть только собаки и кошки, а работа осуществляется в порядке очереди. Люди должны каждый раз
забирать «самое старое» (по времени пребывания в питомнике) животное, но могут выбрать кошку или собаку
(животное в любом случае будет «самым старым»). Нельзя выбрать любое понравившееся животное. Создайте структуру
данных, которая обеспечивает функционирование этой системы и реализует операции enqueue, dequeueAny, dequeueDog и
dequeueCat. Разрешается использование встроенной структуры данных LinkedList.