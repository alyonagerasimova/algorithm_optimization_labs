1. Для заданного направленного графа разработайте алгоритм, проверяющий существование маршрута между двумя узлами.
2. Напишите алгоритм создания бинарного дерева поиска с минимальной высотой для отсортированного (по возрастанию)
массива с уникальными целочисленными элементами.
3. Для бинарного дерева разработайте алгоритм, который создает связный список всех узлов, находящихся на каждой глубине
(для дерева с глубиной 0 должно получиться 0 связных списков).
4. Реализуйте функцию, проверяющую сбалансированность бинарного дерева. Будем считать дерево сбалансированным,
если разница высот двух поддеревьев любого узла не превышает 1.
5. Реализуйте функцию для проверки того, является ли бинарное дерево бинарным деревом поиска.
6. Напишите алгоритм поиска «следующего» узла для заданного узла в бинарном дереве поиска. Считайте, что у каждого узла
есть ссылка на его родителя.
7. Имеется список проектов и список зависимостей (список пар проектов, для которых первый проект зависит от второго
проекта). Проект может быть построен только после построения всех его зависимостей. Найдите такой порядок построения,
который позволит построить все проекты. Если действительного порядка не существует, верните признак ошибки.
Пример:
Ввод:
проекты : а, Ь, с, d, е, f
зависимости : (d, а), (b, f), (d, b), (а, f), (с, d)
Вывод:
f, е, а, b, d, с
8. Создайте алгоритм и напишите код поиска первого общего предка двух узлов бинарного дерева. Постарайтесь избежать
хранения дополнительных узлов в структуре данных. Примечание: бинарное дерево не обязательно является бинарным деревом поиска.
9. Бинарное дерево поиска было создано обходом массива слева направо и вставкой каждого элемента. Для заданного
бинарного дерева поиска с разными элементами выведите все возможные массивы, которые могли привести к созданию этого дерева.
Пример:
Ввод:
Корень 2, левый подузел 1, правый подузел 3
Вывод: { 2, 1, 3 }, { 2, 3, 1 }
10. Т1 и Т2 – два очень больших бинарных дерева, причем Т1 значительно больше Т2. Создайте алгоритм, проверяющий,
является ли Т2 поддеревом Т1. Дерево Т2 считается поддеревом T1, если существует такой узел n в Т1, что поддерево,
«растущее» из n, идентично дереву Т2. (Иначе говоря, если вырезать дерево в узле n, оно будет идентично Т2.)
11. Вы пишете с нуля класс бинарного дерева поиска, который помимо методов вставки, поиска и удаления содержит метод
getRandomNode() для получения случайного узла дерева. Вероятность выбора всех узлов должна быть одинаковой.
Разработайте и реализуйте алгоритм getRandomNode; объясните, как вы реализуете остальные методы.
12. Дано бинарное дерево, в котором каждый узел содержит целое число (положительное или отрицательное). Разработайте
алгоритм для подсчета всех путей, сумма значений которых соответствует заданной величине. Обратите внимание, что путь
не обязан начинаться или заканчиваться в корневом или листовом узле, но он должен идти вниз (переходя только от
родительских узлов к дочерним).



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1. Даны два 32-разрядных числа N и М и две позиции битов i и j. Напишите метод для вставки M в N так, чтобы число М
занимало позицию с бита j по бит i. Предполагается, что j и i имеют такие значения, что число М гарантированно
поместится в этот промежуток. Скажем, для М = 10011 можно считать, что j и i разделены как минимум 5 битами.
Комбинация вида j = 3 и i = 2 невозможна, так как число М не поместится между битом 3 и битом 2.Пример:
Ввод: N = 10000000000, М = 10011, i = 2, j = 6 Вывод: N = 100010011002.
2. Дано вещественное число в интервале между 0 и 1 (например, 0.72), которое передается в формате double. Выведите его
двоичное представление. Если для точного двоичного представления числа не хватает 32 разрядов, выведите сообщение об ошибке.
3. Имеется целое число, в котором можно изменить ровно один бит из 0 в 1. Напишите код для определения длины самой
длинной последовательности единиц, которая может быть при этом получена.Пример:Ввод: 1775 (или : 11011101111) Вывод: 84.
4. Для заданного положительного числа выведите ближайшие наименьшее и наибольшее числа, которые имеют такое же
количество единичных битов в двоичном представлении.
5. Объясните, что делает код: (n & (n-1)) == 0.6.
6. Напишите функцию, определяющую количество битов, которые необходимо изменить, чтобы из целого числа А получить целое
число В.Пример:Ввод: 29 (или 11101), 15 (или 01111) Вывод: 27.
7. Напишите программу, меняющую местами четные и нечетные биты числа с минимальным количеством инструкций (например,
меняются местами биты 0 и 1, биты 2 и 3 и т. д.).
8. Содержимое монохромного экрана хранится в одномерном массиве байтов, так что в одном байте содержится информация о
восьми соседних пикселах. Ширина изображения w кратна 8 (то есть байты не переходят между столбцами). Высоту экрана
можно рассчитать, зная длину массива и ширину экрана. Реализуйте функцию, которая рисует горизонтальную линию из точки
(x1, у) в точку ( х2, у).Сигнатура метода должна выглядеть примерно так:
drawLine(byte[] screen, int width, int x1, int х2, int у)