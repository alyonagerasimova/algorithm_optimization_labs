1. Для заданного направленного графа разработайте алгоритм, проверяющий существование маршрута между двумя узлами.
2. Напишите алгоритм создания бинарного дерева поиска с минимальной высотой для отсортированного (по возрастанию)
массива с уникальными целочисленными элементами.
3. Для бинарного дерева разработайте алгоритм, который создает связный список всех узлов, находящихся на каждой глубине
(для дерева с глубиной 0 должно получиться 0 связных списков).
4. Реализуйте функцию, проверяющую сбалансированность бинарного дерева. Будем считать дерево сбалансированным,
если разница высот двух поддеревьев любого узла не превышает 1.
5. Реализуйте функцию для проверки того, является ли бинарное дерево бинарным деревом поиска.
6. Напишите алгоритм поиска «следующего» узла для заданного узла в бинарном дереве поиска. Считайте, что у каждого узла
есть ссылка на его родителя.
7. Имеется список проектов и список зависимостей (список пар проектов, для которых первый проект зависит от второго
проекта). Проект может быть построен только после построения всех его зависимостей. Найдите такой порядок построения,
который позволит построить все проекты. Если действительного порядка не существует, верните признак ошибки.
Пример:
Ввод:
проекты : а, Ь, с, d, е, f
зависимости : (d, а), (b, f), (d, b), (а, f), (с, d)
Вывод:
f, е, а, b, d, с
8. Создайте алгоритм и напишите код поиска первого общего предка двух узлов бинарного дерева. Постарайтесь избежать
хранения дополнительных узлов в структуре данных. Примечание: бинарное дерево не обязательно является бинарным деревом поиска.
9. Бинарное дерево поиска было создано обходом массива слева направо и вставкой каждого элемента. Для заданного
бинарного дерева поиска с разными элементами выведите все возможные массивы, которые могли привести к созданию этого дерева.
Пример:
Ввод:
Корень 2, левый подузел 1, правый подузел 3
Вывод: { 2, 1, 3 }, { 2, 3, 1 }
10. Т1 и Т2 – два очень больших бинарных дерева, причем Т1 значительно больше Т2. Создайте алгоритм, проверяющий,
является ли Т2 поддеревом Т1. Дерево Т2 считается поддеревом T1, если существует такой узел n в Т1, что поддерево,
«растущее» из n, идентично дереву Т2. (Иначе говоря, если вырезать дерево в узле n, оно будет идентично Т2.)
11. Вы пишете с нуля класс бинарного дерева поиска, который помимо методов вставки, поиска и удаления содержит метод
getRandomNode() для получения случайного узла дерева. Вероятность выбора всех узлов должна быть одинаковой.
Разработайте и реализуйте алгоритм getRandomNode; объясните, как вы реализуете остальные методы.
12. Дано бинарное дерево, в котором каждый узел содержит целое число (положительное или отрицательное). Разработайте
алгоритм для подсчета всех путей, сумма значений которых соответствует заданной величине. Обратите внимание, что путь
не обязан начинаться или заканчиваться в корневом или листовом узле, но он должен идти вниз (переходя только от
родительских узлов к дочерним).